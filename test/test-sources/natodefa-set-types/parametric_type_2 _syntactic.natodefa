letT point t = {x = t} in
let (p : (point <int>)) = {x = 1} in
p

let (x : int) = 1 in
let (x : {int = {}}) = 1 in

strategy: 
    - write types as expressions (i.e. int in e)
    - every time we see (x : tau), we do (reify tau).check x <- very much in parallel to sem_t_of
    - e.g.: 
        -- tau = {a : int, b : {c : bool}}
        tau = 
            { rec = 
                { a = { int = {}}, 
                  b = { rec = 
                        {c = {bool = {}}}
                      , labels = ["c"]
                      }
                }
            , labels = ["a", "b"]
            }
        -- reify tau
        match tau with
        | {rec = r, labels = lbls} ->
            for each lbl in lbls
            match r with
            | {lbl = }
    
let rec reify t = 
    match t with
    | {int = {}} -> {g = fun null -> input, c = ...}
    | {bool = {}} -> ...
    | {tvar = v} -> v v
    | {rec = r} ->
        match r with
        | {}
    | {list = t} ->
        check_list reify t
    | {dom = t1, cod = t2} ->
        let gf = 
            fun t1v ->
                let t1c = (reify t1).checker in
                if (t1c t1v)
                then 
                    let t2g = (reify t2).gen in
                    (t2g 0)
                else 
                    assert false
        in
        let cf = 
            fun f ->
                let t1g = (reify t1).gen in
                let t1v = (t1g 0) in
                let t2c = (reify t2).check in
                t2c (f t1v)
        in
        {g = gf, c = cf}
    | {untouched = }